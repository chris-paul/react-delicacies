<!--
 * @Description: webpack的基本配置
 * @Author: 廉恒凯
 * @Date: 2019-08-20 22:18:30
 * @LastEditTime : 2019-12-28 09:21:49
 * @LastEditors  : Please set LastEditors
 -->

### webpack.base.conf

+ HtmlWebpackPlugin --根据指定的模版自动添加依赖

```javascript
title: 'react-delicacies',
template: 'public/index.html',
/* 移除注释 */
removeComments: true,
/* 移除空格 */
collapseWhitespace: true,
/* 移除多余的属性 */
removeRedundantAttributes: true,
useShortDoctype: true,
/* 移除空的属性 */
removeEmptyAttributes: true,
/* 移除style和link的type属性 */
removeStyleLinkTypeAttributes: true,
keepClosingSlash: true,
/* 生产环境回去压缩代码 */
minifyJS: true,
minifyCSS: true,
minifyURLs: true
```

+ CleanWebpackPlugin --清理dist包

+ MiniCssExtractPlugin --抽离CSS但是我们使用的router的动态加载,所以会为每一个路由生成一个CSS

+ OptimizeCssAssetsPlugin 压缩css

+ NamedModulesPlugin 热更新时候返回模块名而不是id

+ 配置webpack的optimization

```javascript
/* optimization 相关配置 */
optimization: {
    /* 默认是压缩的,生效的前提是mode= */
   minimizer: [
        /* 压缩js */
        new TerserPlugin({
            test: /(\.jsx|\.js)$/,
            extractComments: true,  /* 将注释提取到另外一个文件 */
            parallel: true,   /* 开启多线程,开启的个数跟内核有关 */
            cache: true /* 启用文件缓存。缓存目录的默认路径：node_modules/.cache/terser webpack plugin */
        })
    ],
    /* 代码分离, 统一入口 */
    splitChunks: {
        /* 这里开始设置缓存的 chunks */
        cacheGroups: {
            vendors: {
                /* node_modules里的代码抽离为单独的文件并缓存 */
                test:/[\\/]node_modules[\\/]/,
                chunks: 'initial',
                name:'vendors',
                priority:10,
                enforce:true
            }
        }
    },
    /* 它的作用是将包含chunks 映射关系的 list单独从 app.js里提取出来，因为每一个 chunk 的 id 基本都是基于内容 hash 出来的，所以你每次//改动都会影响它，如果不将它提取出来的话，等于app.js每次都会改变。缓存就失效了 */
    runtimeChunk:{
        name:'manifest'
    }
},
alias: {
    api: path.resolve(__dirname,'utils/api')
},
module: {
    rules: [
        /* 除了/node_modules/的所以的css都需要提取,处理css模块化,具体的配置可以参考h
        ttps://juejin.im/entry/5826e755c4c9710054313d6e
        https://www.cnblogs.com/walls/p/9153555.html */
        {
            test: /\.css$/,
            exclude: path.resolve(__dirname, '../node_modules'),
            use: [
                MiniCssExtractPlugin.loader,
                {
                    loader: 'css-loader',
                    options: {
                        /* 在css-loader之前是否还有其他的loader,(或许以后需要引入post-css-loader)
                        编译css类名 */
                        importLoaders: 0,
                        /* css 模块化 */
                        modules: true,
                        localIdentName: '[path][name]__[local]--[hash:base64:5]'
                    }
                }
            ]
        },
        /* 针对node-module里面的不需要编译类名字,处理node-module里面的css主要是因为antd */
        {
            test: /\.css$/,
            use: [
                MiniCssExtractPlugin.loader,
                'css-loader'
            ],
            include: path.resolve(__dirname, '../node_modules')
        },
    ]
},
hardSourceWebpack: new HardSourceWebpackPlugin({
    /* 缓存的目录：绝对路径或相对于webpack的的上下文 */
    cacheDirectory: path.resolve(__dirname, '../node_modules/.cache/hard-source/[confighash]'),
    /*configHash: function (webpackConfig) {
    可以使用node-object-hash来生成hash
    return require('node-object-hash')({sort: false}).hash(webpackConfig);
    },*/
    /* 当加载器，插件，其他构建时脚本或其他动态依赖项发生更改时，hard-source需要替换缓存以确保输出正确
    environmentHash被用来确定这一点。如果散列与先前的构建不同，则将使用新的缓存 */
    environmentHash: {
        root: process.cwd(),
        directories: [],
        files: ['package-lock.json', 'yarn.lock'],
    },
    /* 打印消息的情况
    要向下报告的日志消息级别。当mode模式为“none”时，默认为“debug”。当模式为'test'时，默认为'warn'。
    'debug'报告所有消息，而'warn'报告警告和错误级别消息。*/
    info: {
        mode: 'none',
        level: 'debug'
    },
    /* 自动清除缓存设置 */
    cachePrune: {
        /* 意思就是这段时间内不会清楚缓存，换言之就是这段时间内可以提升构建速度 */
        maxAge: 24 * 60 * 60 * 1000,
        /*如果缓存大于该设置的值就删除 默认超过50M就删除 */
        sizeThreshold: 50 * 1024 * 1024
    },
}),
```

### webpack-dev-server

+ webpack-dev-server会根据webpack的配置启动一个服务，然后自动build我们每次修改之后的代码，然后刷新浏览器
并且这些编译之后的文件是存在内存中的，加快了访问速度(如果磁盘中存在会优先访问磁盘中的文件)

```javascript
/* 默认已经会开启监听文件变化 */
 devServer: {
    hot: false,
     /* 如果访问index就映射到index.html */
    historyApiFallback: true,
    /* webpack服务器的搭建目录是dist */
    contentBase: './',
    compress: true,
    port: 3333
},
```
### HMR CSS处理(处理CSSHMR)

+  mini-css-extract-plugin,将CSS提取为独立的文件的插件,异步加载,只针对CSS,但是无法使用HMR,所以只可以用于生产环境

+ MiniCssExtractPlugin.loader无法和style—loader兼容,

+ 所以style-loader用于开发环境,他支持HMR,不然每一次保存都需触发mini-css-extract-plugin

### icons过大

+ 官方倒入图库方法是import * as allIcons from '@ant-design/icons/lib/dist',打包过大的根源就在此(源码地址
https://github.com/ant-design/ant-design/blob/4a41dd18489cf175c5db2d683b6bf7c615579d19/components/icon/index.tsx#L3)

+ npm install --save @ant-design/icons

+ 新增'@ant-design/icons/lib/dist$': path.resolve(__dirname, '../websrc/CommonComponents/antdIcon'),做Icon的动态引入

### 注意

+ loader是十分费时间的,path.resolve可以提高速度

+ css模块化和antd是冲突的，所以对css和less必须对src和node-module里面的分开匹配

+ MiniCssExtractPlugin.loader使用了以后不要使用style—loader

+ 因为要对css模块化,所以对antd必须特殊处理
