<!--
 * @Description: webpack的基本配置
 * @Author: 廉恒凯
 * @Date: 2019-08-20 22:18:30
 * @LastEditTime: 2020-04-12 16:12:08
 * @LastEditors: 廉恒凯
 -->

### webpack.base.conf

-   HtmlWebpackPlugin --根据指定的模版自动添加依赖

```javascript
title: 'react-delicacies',
template: 'public/index.html',
/* 移除注释 */
removeComments: true,
/* 移除空格 */
collapseWhitespace: true,
/* 移除多余的属性 */
removeRedundantAttributes: true,
useShortDoctype: true,
/* 移除空的属性 */
removeEmptyAttributes: true,
/* 移除style和link的type属性 */
removeStyleLinkTypeAttributes: true,
keepClosingSlash: true,
/* 生产环境回去压缩代码 */
minifyJS: true,
minifyCSS: true,
minifyURLs: true
```

-   CleanWebpackPlugin --清理 dist 包

-   MiniCssExtractPlugin --抽离 CSS 但是我们使用的 router 的动态加载,所以会为每一个路由生成一个 CSS

-   OptimizeCssAssetsPlugin 压缩 css

-   NamedModulesPlugin 热更新时候返回模块名而不是 id

-   配置 webpack 的 optimization

```javascript
/* optimization 相关配置 */
optimization: {
    /* 默认是压缩的,生效的前提是mode= */
   minimizer: [
        /* 压缩js */
        new TerserPlugin({
            test: /(\.jsx|\.js)$/,
            extractComments: true,  /* 将注释提取到另外一个文件 */
            parallel: true,   /* 开启多线程,开启的个数跟内核有关 */
            cache: true /* 启用文件缓存。缓存目录的默认路径：node_modules/.cache/terser webpack plugin */
        })
    ],
    /* 代码分离, 统一入口 */
    splitChunks: {
        /* 这里开始设置缓存的 chunks,splitChunks根据cacheGroups来混存代码  */
        cacheGroups: {
            /* 缓存组的名字 */
            vendors: {
                /* node_modules里的代码抽离为单独的文件并缓存 */
                test:/[\\/]node_modules[\\/]/,
                /* async表示只从动态import的代码中拆分,默认是initial, initial表示只从入口模块拆分, all表示以上两者都包括 */
                chunks: 'initial',
                /* 当chunk没有名字时，通过splitChunks分出的模块的名字用id替代，当然你也可以通过name属性自定义,不配置name,这个时候会chunks为all */
                name:'vendors',
                /* 优先级 */
                priority:10,
                enforce:true
            }
        }
    },
    /* 它的作用是将包含chunks 映射关系的 list单独从 app.js里提取出来，因为每一个 chunk 的 id 基本都是基于内容 hash 出来的，所以你每次//改动都会影响它，如果不将它提取出来的话，等于app.js每次都会改变。缓存就失效了 */
    runtimeChunk:{
        name:'manifest'
    }
},
alias: {
    api: path.resolve(__dirname,'utils/api')
},
module: {
    rules: [
        /* 除了/node_modules/的所以的css都需要提取,处理css模块化,具体的配置可以参考h
        ttps://juejin.im/entry/5826e755c4c9710054313d6e
        https://www.cnblogs.com/walls/p/9153555.html */
        {
            test: /\.css$/,
            exclude: path.resolve(__dirname, '../node_modules'),
            use: [
                MiniCssExtractPlugin.loader,
                {
                    loader: 'css-loader',
                    options: {
                        /* 在css-loader之前是否还有其他的loader,(或许以后需要引入post-css-loader)
                        编译css类名 */
                        importLoaders: 0,
                        /* css 模块化 */
                        modules: true,
                        localIdentName: '[path][name]__[local]--[hash:base64:5]'
                    }
                }
            ]
        },
        /* 针对node-module里面的不需要编译类名字,处理node-module里面的css主要是因为antd */
        {
            test: /\.css$/,
            use: [
                MiniCssExtractPlugin.loader,
                'css-loader'
            ],
            include: path.resolve(__dirname, '../node_modules')
        },
    ]
},
hardSourceWebpack: new HardSourceWebpackPlugin({
    /* 缓存的目录：绝对路径或相对于webpack的的上下文 */
    cacheDirectory: path.resolve(__dirname, '../node_modules/.cache/hard-source/[confighash]'),
    /*configHash: function (webpackConfig) {
    可以使用node-object-hash来生成hash
    return require('node-object-hash')({sort: false}).hash(webpackConfig);
    },*/
    /* 当加载器，插件，其他构建时脚本或其他动态依赖项发生更改时，hard-source需要替换缓存以确保输出正确
    environmentHash被用来确定这一点。如果散列与先前的构建不同，则将使用新的缓存 */
    environmentHash: {
        root: process.cwd(),
        directories: [],
        files: ['package-lock.json', 'yarn.lock'],
    },
    /* 打印消息的情况
    要向下报告的日志消息级别。当mode模式为“none”时，默认为“debug”。当模式为'test'时，默认为'warn'。
    'debug'报告所有消息，而'warn'报告警告和错误级别消息。*/
    info: {
        mode: 'none',
        level: 'debug'
    },
    /* 自动清除缓存设置 */
    cachePrune: {
        /* 意思就是这段时间内不会清楚缓存，换言之就是这段时间内可以提升构建速度 */
        maxAge: 24 * 60 * 60 * 1000,
        /*如果缓存大于该设置的值就删除 默认超过50M就删除 */
        sizeThreshold: 50 * 1024 * 1024
    },
}),
```

### webpack-dev-server

-   webpack-dev-server 会根据 webpack 的配置启动一个服务，然后自动 build 我们每次修改之后的代码，然后刷新浏览器并且这些编译之后的文件是存在内存中的，加快了访问速度(如果磁盘中存在会优先访问磁盘中的文件)

```javascript
/* 默认已经会开启监听文件变化 */
 devServer: {
    hot: false,
     /* 如果访问index就映射到index.html */
    historyApiFallback: true,
    /* webpack服务器的搭建目录是dist */
    contentBase: './',
    compress: true,
    port: 3333
},
```

### HMR CSS 处理(处理 CSSHMR)

-   mini-css-extract-plugin,将 CSS 提取为独立的文件的插件,异步加载,只针对 CSS,但是无法使用 HMR,所以只可以用于生产环境

-   MiniCssExtractPlugin.loader 无法和 style—loader 兼容,

-   所以 style-loader 用于开发环境,他支持 HMR,不然每一次保存都需触发 mini-css-extract-plugin

### icons 过大

-   官方倒入图库方法是 import \* as allIcons from '@ant-design/icons/lib/dist',打包过大的根源就在此(源码地址 https://github.com/ant-design/ant-design/blob/4a41dd18489cf175c5db2d683b6bf7c615579d19/components/icon/index.tsx#L3)

-   npm install --save @ant-design/icons

-   新增'@ant-design/icons/lib/dist\$': path.resolve(\_\_dirname, '../websrc/CommonComponents/antdIcon'),做 Icon 的动态引入

### 注意

-   loader 是十分费时间的,path.resolve 可以提高速度

-   css 模块化和 antd 是冲突的，所以对 css 和 less 必须对 src 和 node-module 里面的分开匹配

-   MiniCssExtractPlugin.loader 使用了以后不要使用 style—loader

-   因为要对 css 模块化,所以对 antd 必须特殊处理

### gzip 压缩

#### nginx 等服务器本身支持 gzip

-   浏览器请求资源文件时会自动带一个 Accept-Encoding 的请求头告诉服务器支持的压缩编码类型

-   如果服务器开启了 gzip,接收客户端资源文件请求，查看请求头 Content-encoding 支持的压缩编码格式，如果是包含 gzip 那么在每次响应资源请求之前进行 gzip 编码压缩后再响应返回资源文件(在响应头会带上 Content-encoding: gzip)

-   浏览器接收到响应后查看请求头是否带有 Content-encoding:gzip，如果有进行对返回的资源文件进行解压缩然后再进行解析渲染

    -   每次压缩其实是需要消耗服务器的 cpu 的

#### webpack CompressionPlugin 优化

-   这样服务器查找到有与源文件同名的.gz 文件就会直接读取，不会主动压缩，降低 cpu 负载，优化了服务器性能

### 性能提示

-   webpack打包的时候会有如下的性能提示,其实可以配置performance参数解决,但是暂时不解决,包太大其实需要优化,暂时gzip压缩后已经达到了92k
    ```
    WARNING in asset size limit: The following asset(s) exceed the recommended size limit (244 KiB). This can impact web performance
    ```
